Generated Package
*****************

Output Structure
================
PeakRDL Python generates a python packages from a System RDL design, structured
as shown below. The ``root_name`` will be based on the top level address map name
with the package was generated

| ``<root_name>``
| ├── ``reg_model``
| │ ├── ``<root_name>.py``
| │ └── ``peakrdl_python_types.py``
| └── ``reg_model``
|   └── ``test_<root_name>.py``

In the folder structure above:

- ``<root_name>.py`` - This is the register abstraction layer code for the design
- ``peakrdl_python_types.py`` - This is a module of base classes used by the register abstraction layer
- ``test_<root_name>.py`` - This is a set of autogenerated unittests to verify the register abstraction layer

Running the Unit Tests
======================

There are many ways to run Python Unit tests. A good place to start is the ``unittest`` module
included in the Python standard installation.

Callbacks
=========

The Register Abstraction Layer will typically interfaced to a driver that
allows accesses the chip. However, it can also be interfaced to a simulation
of the device.

In order to operate the register abstraction layer requires the following:

- A callback for a single register write
- A callback for a single register read

The examples of these two methods are included within the generated register
access layer package so that it can be used from the console:

.. code-block:: python

    def read_addr_space(addr: int, width: int, accesswidth: int) -> int:
        """
        Callback to simulate the operation of the package, everytime the read is called, it will
        request the user input the value to be read back.

        Args:
            addr: Address to write to
            width: Width of the register in bits
            accesswidth: Minimium access width of the register in bits

        Returns:
            value inputted by the used
        """
        assert isinstance(addr, int)
        assert isinstance(width, int)
        assert isinstance(accesswidth, int)
        return input('value to read from address:0x%X' % addr)

    def write_addr_space(addr: int, width: int, accesswidth: int, data: int) -> NoReturn:
        """
        Callback to simulate the operation of the package, everytime the read is called, it will
        request the user input the value to be read back.

        Args:
            addr: Address to write to
            width: Width of the register in bits
            accesswidth: Minimium access width of the register in bits
            data: value to be written to the register

        Returns:
            None
        """
        assert isinstance(addr, int)
        assert isinstance(width, int)
        assert isinstance(accesswidth, int)
        assert isinstance(data, int)
        print('write data:0x%X to address:0x%X' % (data, addr))

In a real system these call backs will be connected to a driver.

Using the Register Abstraction Layer
====================================

The register abstraction layer package is intended to integrated into another
piece of code. That code could be a simple test script for blinking an LED on a
GPIO or it could be a more complex application with a GUI.

The following example is a chip that has a GPIO block. The GPIO block has two
registers:

1. one register that controls the direction of the GPIO pin, at address 0x4
2. one register that controls driven state of the GPIO pin, at address 0x8

This can be described with the following systemRDL code:

.. code-block:: systemRDL

    addrmap mychip {

        name="My Chip";

        addrmap GPIO_block {

            name = "GPIO Block";
            desc = "GPIO Block with configurable direction pins";

            enum GPIO_direction {
                dir_in = 0 { name = "input"; desc="GPIO direction into chip"; };
                dir_out = 1 { name = "output"; desc="GPIO direction out of chip"; };
            };

            field GPIO_direction_field_type {
                encode=GPIO_direction;
                fieldwidth = 1;
                sw=rw;
                hw=r;
                reset={GPIO_direction::dir_in}; };
            field GPIO_output_field_type {
                fieldwidth = 1;
                sw=rw;
                hw=r; };

            reg {
                name="GPIO Direction";
                desc="Register to set the direction of each GPIO pin";
                GPIO_direction_field_type PIN_0;
            } GPIO_dir @ 0x4;

            reg {
                name="GPIO Set State";
                desc="Register to set the state of a GPIO Pin";
                GPIO_output_field_type PIN_0;
            } GPIO_state @ 0x8;
        } GPIO;
    };

This systemRDL code can be built using the command line tool as follows (assuming it is stored in
a file called ``chip_with_a_GPIO.rdl``:

.. code-block:: bash

    peakpython chip_with_a_GPIO.rdl --outdir python_output --test

.. note:: It is always good practice to use the ``--test`` command line argument to run the
          unittests on the generated code.

Once the register abstraction layer has been generated and it can be used. The following example
does not actually use a device driver. Instead it chip simulator with a a Tkinter GUI,
incorporating a RED circle to represent the LED. The chip simulator has read and write methods (
equivalent to those offered by a device driver), these look at the address of the write and update
the internal state of the simulator accordingly, the LED is then updated based on the state of the
simulator.

.. code-block:: python

    import tkinter as tk

    from typing import NoReturn

    from mychip.reg_model.mychip import mychip_cls

    class ChipSim:

        def __init__(self):

            # simulator state variables
            self.PIN_output = False
            self.PIN_state = False

            # basic GUI components
            self.root = tk.Tk()
            self.root.title("My Chip Simulator")
            self.LED_label = tk.Label(master=self.root,
                                      text="LED_0",
                                      foreground="black")  # Set the background color to black
            self.LED_label.pack(fill=tk.X, side=tk.TOP)
            window_frame = tk.Frame(master=self.root, width=400, height=400,bg="black")
            window_frame.pack(fill=tk.BOTH, side=tk.TOP)
            self.LED = tk.Canvas(master=window_frame, width=300, height=300, bg='black')
            self.LED.pack()
            self.LED_inner = self.LED.create_oval(25, 25, 275, 275, fill='black')

        def read_addr_space(self, addr: int, width: int, accesswidth: int) -> int:
            """
            Callback to for the simulation of the chip

            Args:
                addr: Address to write to
                width: Width of the register in bits
                accesswidth: Minimum access width of the register in bits

            Returns:
                simulated register value
            """
            assert isinstance(addr, int)
            assert isinstance(width, int)
            assert isinstance(accesswidth, int)

            if addr == 0x4:
                if self.PIN_output is True:
                    return 0x1
                else:
                    return 0x0
            elif addr == 0x8:
                if self.PIN_state is True:
                    return 0x1
                else:
                    return 0x0

        def write_addr_space(self, addr: int, width: int, accesswidth: int, data: int) -> NoReturn:
            """
            Callback to for the simulation of the chip

            Args:
                addr: Address to write to
                width: Width of the register in bits
                accesswidth: Minimum access width of the register in bits
                data: value to be written to the register

            Returns:
                None
            """
            assert isinstance(addr, int)
            assert isinstance(width, int)
            assert isinstance(accesswidth, int)
            assert isinstance(data, int)

            if addr == 0x4:
                if (data & 0x1) == 0x1:
                    self.PIN_output = True
                else:
                    self.PIN_output = False
            elif addr == 0x8:
                if (data & 0x1) == 0x1:
                    self.PIN_state = True
                else:
                    self.PIN_state = False

            self.update_LED()

        def update_LED(self):

            if self.PIN_output is True:
                # LED is enabled
                if self.PIN_state is True:
                    self.LED.itemconfig(self.LED_inner, fill='red')
                else:
                    self.LED.itemconfig(self.LED_inner, fill='black')
            else:
                self.LED.itemconfig(self.LED_inner, fill='black')

    # these two methods can be put in the simulator Tkinter event queue to perform register writes on
    # the register abstraction layer (in turn causing the state of the simulator to change)

    def turn_LED_on(chip: mychip_cls, sim_kt_root):

        # write a '1' to the LED state field
        chip.GPIO.GPIO_state.PIN_0.write(1)
        # set up another event to happen
        sim_kt_root.after(2000, turn_LED_off, chip, sim_kt_root)

    def turn_LED_off(chip: mychip_cls, sim_kt_root):

        # write a '0' to the LED state field
        chip.GPIO.GPIO_state.PIN_0.write(0)
        # set up another event to happen
        sim_kt_root.after(2000, turn_LED_on, chip, sim_kt_root)


    if __name__ == '__main__':

        # make an instance of the chip simulator and then locally defined the callbacks that will be
        # used to by the register abstraction model
        chip_simulator = ChipSim()

        def read_call_back(addr: int, width: int, accesswidth: int):
            return chip_simulator.read_addr_space(addr=addr,
                                                  width=width,
                                                  accesswidth=accesswidth)
        def write_call_back(addr: int, width: int, accesswidth: int, data: int):
            chip_simulator.write_addr_space(addr=addr,
                                            width=width,
                                            accesswidth=accesswidth,
                                            data=data)

        # created an instance of the register model and connect the callbacks to the simulator
        mychip = mychip_cls(read_callback=read_call_back, write_callback=write_call_back)

        # configure the GPIO.PIN_0 as an output
        mychip.GPIO.GPIO_dir.PIN_0.write(mychip.GPIO.GPIO_dir.PIN_0.enum_cls.dir_out)

        # set up the first event to turn the LED on after 2s (this event will then set-up a follow up
        # event to turn it off. This sequencer repeats forever.
        chip_simulator.root.after(2000, turn_LED_on, mychip, chip_simulator.root)
        # start the GUI (simulator)
        chip_simulator.root.mainloop()