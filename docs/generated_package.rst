Generated Package
*****************

Output Structure
================
PeakRDL Python generates a python packages from a System RDL design, structured
as shown below. The ``root_name`` will be based on the top level address map name
with the package was generated

| ``<root_name>``
| ├── ``lib``
| ├── ``reg_model``
| │ └── ``<root_name>.py``
| └── ``tests``
|   └── ``test_<root_name>.py``

In the folder structure above:

- ``<root_name>.py`` - This is the register abstraction layer code for the design
- ``lib`` - This is a package of base classes used by the register abstraction layer
- ``test_<root_name>.py`` - This is a set of autogenerated unittests to verify the register abstraction layer

Running the Unit Tests
======================

There are many ways to run Python Unit tests. A good place to start is the ``unittest`` module
included in the Python standard installation.

Callbacks
=========

The Register Abstraction Layer will typically interfaced to a driver that
allows accesses the chip. However, it can also be interfaced to a simulation
of the device.

In order to operate the register abstraction layer typically requires the following:

- A callback for a single register write, this not required if there is no writable register in
  the register abstraction layer
- A callback for a single register read, this not required if there is no writable register in
  the register abstraction layer

In addition the register abstraction layer can make use of block operations where a block of the
address space is read in a single transaction. Not all drivers support these

The examples of these two methods are included within the generated register
access layer package so that it can be used from the console:

.. code-block:: python

    def read_addr_space(addr: int, width: int, accesswidth: int) -> int:
        """
        Callback to simulate the operation of the package, everytime the read is called, it will
        request the user input the value to be read back.

        Args:
            addr: Address to write to
            width: Width of the register in bits
            accesswidth: Minimium access width of the register in bits

        Returns:
            value inputted by the used
        """
        assert isinstance(addr, int)
        assert isinstance(width, int)
        assert isinstance(accesswidth, int)
        return input('value to read from address:0x%X' % addr)

    def write_addr_space(addr: int, width: int, accesswidth: int, data: int) -> NoReturn:
        """
        Callback to simulate the operation of the package, everytime the read is called, it will
        request the user input the value to be read back.

        Args:
            addr: Address to write to
            width: Width of the register in bits
            accesswidth: Minimum access width of the register in bits
            data: value to be written to the register

        Returns:
            None
        """
        assert isinstance(addr, int)
        assert isinstance(width, int)
        assert isinstance(accesswidth, int)
        assert isinstance(data, int)
        print('write data:0x%X to address:0x%X' % (data, addr))

In a real system these call backs will be connected to a driver.

Callback Set
------------

The callbacks are passed into the register abstraction layer using a ``CallbackSet``.

Using the Register Abstraction Layer
====================================

The register abstraction layer package is intended to integrated into another
piece of code. That code could be a simple test script for blinking an LED on a
GPIO or it could be a more complex application with a GUI.

The following example is a chip that has a GPIO block. The GPIO block has two
registers:

1. one register that controls the direction of the GPIO pin, at address 0x4
2. one register that controls driven state of the GPIO pin, at address 0x8

This can be described with the following systemRDL code:

.. literalinclude :: ../example/simulating_callbacks/chip_with_a_GPIO.rdl
   :language: systemrdl

This systemRDL code can be built using the command line tool as follows (assuming it is stored in
a file called ``chip_with_a_GPIO.rdl``:

.. code-block:: bash

    peakpython chip_with_a_GPIO.rdl --outdir python_output --test

.. tip:: It is always good practice to use the ``--test`` command line argument to run the
          unittests on the generated code.

Once the register abstraction layer has been generated and it can be used. The following example
does not actually use a device driver. Instead it chip simulator with a a Tkinter GUI,
incorporating a RED circle to represent the LED. The chip simulator has read and write methods (
equivalent to those offered by a device driver), these look at the address of the write and update
the internal state of the simulator accordingly, the LED is then updated based on the state of the
simulator.

.. literalinclude :: ../example/simulating_callbacks/flashing_the_LED.py
   :language: python

Walking the Structure
=====================

The following two example show how to use the generators within the register abstraction layer
package to traverse the structure.

Both examples use the following register set which has a number of features to demonstrate the
structures

.. literalinclude :: ../example/tranversing_address_map/chip_with_registers.rdl
   :language: systemrdl

This systemRDL code can be built using the command line tool as follows (assuming it is stored in
a file called ``chip_with_registers.rdl``:

.. code-block:: bash

    peakpython chip_with_registers.rdl --outdir chip_with_registers --test

Traversing without Unrolling Loops
----------------------------------

The first example is reading all the readable registers from the register map and writing them
into a JSON file. To exploit the capabilities of a JSON file the arrays of registers and
register files must be converted to python lists, therefore the loops must not be unrolled, the
array objects are accessed directly.

.. literalinclude :: ../example/tranversing_address_map/dumping_register_state_to_json_file.py
   :language: python

This will create a JSON file as follows:

.. code-block:: json

    {
        "regfile_array": [
            {
                "single_reg": {
                    "first_field": 0,
                    "second_field": 0
                },
                "reg_array": [
                    {
                        "first_field": 0,
                        "second_field": 0
                    },
                    {
                        "first_field": 0,
                        "second_field": 0
                    },
                    {
                        "first_field": 0,
                        "second_field": 0
                    },
                    {
                        "first_field": 0,
                        "second_field": 0
                    }
                ]
            },
            {
                "single_reg": {
                    "first_field": 0,
                    "second_field": 0
                },
                "reg_array": [
                    {
                        "first_field": 0,
                        "second_field": 0
                    },
                    {
                        "first_field": 0,
                        "second_field": 0
                    },
                    {
                        "first_field": 0,
                        "second_field": 0
                    },
                    {
                        "first_field": 0,
                        "second_field": 0
                    }
                ]
            }
        ],
        "single_regfile": {
            "single_reg": {
                "first_field": 0,
                "second_field": 0
            },
            "reg_array": [
                {
                    "first_field": 0,
                    "second_field": 0
                },
                {
                    "first_field": 0,
                    "second_field": 0
                },
                {
                    "first_field": 0,
                    "second_field": 0
                },
                {
                    "first_field": 0,
                    "second_field": 0
                }
            ]
        }
    }

Traversing without Unrolling Loops
----------------------------------

The second example is setting every register in the address map back to its default values. In
this case the loops are unrolled to conveniently access all the register without needing to
worry if they are in an array or not.

.. literalinclude :: ../example/tranversing_address_map/reseting_registers.py
   :language: python