"""Python Wrapper for the {{top_node.inst_name}} register model

This code was generated from the PeakRDL-python package

"""
{% if top_node.uses_enum %}from enum import IntEnum, unique{% endif %}
from typing import Tuple, NoReturn
from collections.abc import Iterable

from .peakrdl_python_types import AddressMap, Reg, RegFile
from .peakrdl_python_types import RegReadOnly, RegWriteOnly, RegReadWrite
from .peakrdl_python_types import Field, FieldReadOnly, FieldWriteOnly, FieldReadWrite
from .peakrdl_python_types import read_callback_type, write_callback_type

{%- macro field_class(node) %}
    {% if node.is_sw_readable and node.is_sw_writable %}
class {{get_fully_qualified_type_name(node)}}_cls(FieldReadWrite):
    {% elif node.is_sw_readable and not node.is_sw_writable %}
class {{get_fully_qualified_type_name(node)}}_cls(FieldReadOnly):
    {% elif not node.is_sw_readable and node.is_sw_writable %}
class {{get_fully_qualified_type_name(node)}}_cls(FieldWriteOnly):
    {% endif %}
    """
    Class to represent a register field in the register model

    {{get_table_block(node) | indent}}
    """

    {%- if 'encode' in node.list_properties() %}
    __enum_cls = {{get_fully_qualified_enum_type(node.get_property('encode'), top_node.parent)}}_enumcls
    {% endif %}

    __slots__ = []

    {%- if 'encode' in node.list_properties() %}
    @classmethod
    @property
    def enum_cls(cls):
        """
        The enumeration class for this field
        """
        return cls.__enum_cls

        {%- if node.is_sw_readable %}
    def decode_read_value(self, reg_value: int) -> {{get_fully_qualified_enum_type(node.get_property('encode'), top_node.parent)}}_enumcls:
        """
        extracts the field value from a register value, by applying the bit
        mask and shift needed and conversion to the enum associated with the
        field

        Args:
            value: value to decode, normally read from a register

        Returns:
            field value

        Raises:
            ValueError - if the value read back for the field can not be matched to the enum
        """
        field_value = super().decode_read_value(reg_value)

        for potential_value in self.enum_cls:
            if field_value == potential_value.value:
                return potential_value
        else:
            raise ValueError('Unable to match value %d' % field_value)

    def read(self) -> {{get_fully_qualified_enum_type(node.get_property('encode'), top_node.parent)}}_enumcls:
        """
        read the register and then perform the necessary actions, to report the
        value as the enumeration including:

        * application of bit mask
        * bit shifting
        * converting integer value to enum

        Returns:
            field value
        """
        reg_value = self.parent_register.read()
        return self.decode_read_value(reg_value=reg_value)
        {% endif %}

        {%- if node.is_sw_writable %}
    def encode_write_value(self, value: {{get_fully_qualified_enum_type(node.get_property('encode'), top_node.parent)}}_enumcls) -> int:

        if not isinstance(value, self.enum_cls):
            raise TypeError('value must be an {{get_fully_qualified_enum_type(node.get_property('encode'), top_node.parent)}}_enumcls but got %s' % type(value))

        return super().encode_write_value(value.value)

    def write(self, value : {{get_fully_qualified_enum_type(node.get_property('encode'), top_node.parent)}}_enumcls) -> NoReturn:

        if not isinstance(value, self.enum_cls):
            raise TypeError('value must be an {{get_fully_qualified_enum_type(node.get_property('encode'), top_node.parent)}}_enumcls but got %s' % type(value))

        super().write(value.value)
        {% endif %}
    {% endif %}

{%- endmacro -%}

{%- macro register_class(node) %}
    {%- if node.has_sw_readable and node.has_sw_writable %}
class {{get_fully_qualified_type_name(node)}}_cls(RegReadWrite):
    {%- elif node.has_sw_readable and not node.has_sw_writable %}
class {{get_fully_qualified_type_name(node)}}_cls(RegReadOnly):
    {%- elif not node.has_sw_readable and node.has_sw_writable %}
class {{get_fully_qualified_type_name(node)}}_cls(RegWriteOnly):
    {%- endif %}
    """
    Class to represent a register in the register model

    {{get_table_block(node) | indent}}
    """

    __slots__ = [{%- for child_node in node.children(unroll=False) -%}'__{{get_inst_name(child_node)}}'{% if not loop.last %}, {% endif %}{%- endfor %}]

    {%- if node.has_sw_readable and node.has_sw_writable %}

    def __init__(self,
                 read_callback: read_callback_type,
                 write_callback: write_callback_type,
                 logger_handle,
                 base_address,
                 address_width,
                 data_width,
                 inst_name):

        super().__init__(read_callback=read_callback,
                         write_callback=write_callback,
                         base_address=base_address,
                         address_width=address_width,
                         data_width=data_width,
                         logger_handle=logger_handle,
                         inst_name=inst_name)
    {%- elif node.has_sw_readable and not node.has_sw_writable %}

    def __init__(self,
                 read_callback: read_callback_type,
                 logger_handle,
                 base_address,
                 address_width,
                 data_width,
                 inst_name):

        super().__init__(read_callback=read_callback,
                         base_address=base_address,
                         address_width=address_width,
                         data_width=data_width,
                         logger_handle=logger_handle,
                         inst_name=inst_name)
    {%- elif not node.has_sw_readable and node.has_sw_writable %}

    def __init__(self,
                 write_callback: write_callback_type,
                 logger_handle,
                 base_address,
                 address_width,
                 data_width,
                 inst_name):

        super().__init__(write_callback=write_callback,
                         base_address=base_address,
                         address_width=address_width,
                         data_width=data_width,
                         logger_handle=logger_handle,
                         inst_name=inst_name)
    {%- endif %}

        # build the field attributes
        {%- for child_node in node.fields() %}
            {%- if isinstance(child_node, systemrdlFieldNode) %}
        self.__{{get_inst_name(child_node)}} = {{get_fully_qualified_type_name(child_node)}}_cls(parent_register=self,
                                                                                 width={{child_node.width}},
                                                                                 lsb={{child_node.lsb}},
                                                                                 msb={{child_node.msb}},
                                                                                 logger_handle=logger_handle+'.{{get_inst_name(child_node)}}',
                                                                                 inst_name='{{get_inst_name(child_node)}}')
            {%- endif -%}
        {%- endfor %}

    {% if node.has_sw_readable %}
    def read_fields(self):
        """
        read the register and return a dictionary of the field values
        """
        reg_value = self.read()

        return_dict = {
                        {%- for child_node in get_reg_readable_fields(node) %}
                        '{{get_inst_name(child_node)}}' : self.{{get_inst_name(child_node)}}.decode_read_value(reg_value)
                        {%- if not loop.last -%} ,  {%- endif -%}
                        {% endfor %}
                      }

        return return_dict

    @property
    def readable_fields(self) -> Iterable[Field]:
        """
        generator that produces has all the readable fields within the register
        """
        {%- for child_node in get_reg_readable_fields(node) %}
        yield self.{{get_inst_name(child_node)}}
        {% endfor %}

    {% endif %}

    {% if node.has_sw_writable %}
    @property
    def writable_fields(self) -> Iterable[Field]:
        """
        generator that produces has all the writable fields within the register
        """
        {% for child_node in get_reg_writable_fields(node) -%}
        yield self.{{get_inst_name(child_node)}}
        {% endfor %}

    {% if node.has_sw_readable %}
    def write_fields(self, **kwargs) -> NoReturn:
        """
        Do a read-modify-write to the register, updating any field included in
        the arguments
        """

        if len(kwargs) == 0:
            raise ValueError('no command args')

        bit_mask = 0
        reg_value = 0
        {%- for child_node in get_reg_writable_fields(node) %}
        if '{{get_inst_name(child_node)}}' in kwargs:
            reg_value |= self.{{get_inst_name(child_node)}}.encode_write_value(kwargs['{{get_inst_name(child_node)}}'])
            bit_mask |= self.{{get_inst_name(child_node)}}.bitmask
            kwargs.pop('{{get_inst_name(child_node)}}')
        {%- endfor %}
        if len(kwargs) != 0:
            # left over unhandled arguments
            raise ValueError('unrecognised arguments in field')

        inverse_bit_mask = self.max_value ^ bit_mask

        self.write((self.read() & inverse_bit_mask) | reg_value)



    {% else %}
    def write_fields(self, {%- for child_node in node.fields() -%} {{get_inst_name(child_node)}} : int{%- if not loop.last -%},{%- endif -%}{%- endfor -%}) -> NoReturn:
        """
        Do a write to the register, updating all fields
        """
        reg_value = 0
        {%- for child_node in node.fields() %}
        reg_value |= self.{{get_inst_name(child_node)}}.encode_write_value({{get_inst_name(child_node)}})
        {% endfor %}

        self.write(reg_value)
    {% endif %}
    {% endif %}

    # build the properties for the fields
    {%- for child_node in node.children(unroll=False) -%}
        {%- if isinstance(child_node, systemrdlFieldNode) %}
    @property
    def {{get_inst_name(child_node)}}(self) -> {{get_fully_qualified_type_name(child_node)}}_cls:
        return self.__{{get_inst_name(child_node)}}
        {% endif %}
    {%- endfor %}



{%- endmacro %}

{%- macro regfile_or_addr_instance(node) %}
    {%- if isinstance(node, systemrdlRegNode) %}
        {%- if node.is_array %}
            {%- if node.has_sw_readable and node.has_sw_writable %}
    self.__{{get_inst_name(node)}} = ( {% for node_instance_index in range(get_array_dim(node))  %}
                                       {{get_fully_qualified_type_name(node)}}_cls(read_callback=read_callback,
                                                                   write_callback=write_callback,
                                                                   base_address=base_address+{{node.raw_address_offset}}+({{node_instance_index}} * {{node.array_stride}}),
                                                                   address_width=self.address_width,data_width=self.data_width,
                                                                   logger_handle=logger_handle+'.{{get_inst_name(node)}}[{{node_instance_index}}]',
                                                                                   inst_name='{{get_inst_name(node)}}')
                                       {%- if not loop.last -%} ,  {%- endif -%}
                                       {% endfor %} )
            {%- elif node.has_sw_readable and not node.has_sw_writable %}
    self.__{{get_inst_name(node)}} = ( {% for node_instance_index in range(get_array_dim(node))  %}
                                       {{get_fully_qualified_type_name(node)}}_cls(read_callback=read_callback,
                                                                   base_address=base_address+{{node.raw_address_offset}}+({{node_instance_index}} * {{node.array_stride}}),
                                                                   address_width=self.address_width,
                                                                   data_width=self.data_width,
                                                                   logger_handle=logger_handle+'.{{get_inst_name(node)}}[{{node_instance_index}}]',
                                                                                   inst_name='{{get_inst_name(node)}}')
                                       {%- if not loop.last -%} ,  {%- endif -%}
                                       {% endfor %} )
            {%- elif not node.has_sw_readable and node.has_sw_writable %}
    self.__{{get_inst_name(node)}} = ( {% for node_instance_index in range(get_array_dim(node))  %}
                                       {{get_fully_qualified_type_name(node)}}_cls(write_callback=write_callback,
                                                                   base_address=base_address+{{node.raw_address_offset}}+({{node_instance_index}} * {{node.array_stride}}),
                                                                   address_width=self.address_width,
                                                                   data_width=self.data_width,
                                                                   logger_handle=logger_handle+'.{{get_inst_name(node)}}[{{node_instance_index}}]',
                                                                                   inst_name='{{get_inst_name(node)}}')
                                       {%- if not loop.last -%} ,  {%- endif -%}
                                       {% endfor %} )
            {%- endif %}
        {%- else %}
            {%- if node.has_sw_readable and node.has_sw_writable %}
    self.__{{get_inst_name(node)}} = {{get_fully_qualified_type_name(node)}}_cls(read_callback=read_callback,
                                                                 write_callback=write_callback,
                                                                 base_address=base_address+{{node.address_offset}},
                                                                 address_width=self.address_width,
                                                                 data_width=self.data_width,
                                                                 logger_handle=logger_handle+'.{{get_inst_name(node)}}',
                                                                                   inst_name='{{get_inst_name(node)}}')
            {%- elif node.has_sw_readable and not node.has_sw_writable %}
    self.__{{get_inst_name(node)}} = {{get_fully_qualified_type_name(node)}}_cls(read_callback=read_callback,
                                                                 base_address=base_address+{{node.address_offset}},
                                                                 address_width=self.address_width,
                                                                 data_width=self.data_width,
                                                                 logger_handle=logger_handle+'.{{get_inst_name(node)}}',
                                                                                   inst_name='{{get_inst_name(node)}}')
            {%- elif not node.has_sw_readable and node.has_sw_writable %}
    self.__{{get_inst_name(node)}} = {{get_fully_qualified_type_name(node)}}_cls(write_callback=write_callback,
                                                                                 base_address=base_address+{{node.address_offset}},
                                                                                 address_width=self.address_width,
                                                                                 data_width=self.data_width,
                                                                                 logger_handle=logger_handle+'.{{get_inst_name(node)}}',
                                                                                   inst_name='{{get_inst_name(node)}}')
            {%- endif %}
        {%- endif %}
    {%- elif isinstance(node, systemrdlRegfileNode) or isinstance(node, systemrdlAddrmapNode) %}
        {%- if node.is_array %}
    self.__{{get_inst_name(node)}} = ( {% for node_instance_index in range(get_array_dim(node))  %}
                                       {{get_fully_qualified_type_name(node)}}_cls(read_callback=read_callback,
                                                                                   write_callback=write_callback,
                                                                                   base_address=base_address+{{node.raw_address_offset}}+({{node_instance_index}} * {{node.array_stride}}),
                                                                                   address_width=self.address_width,
                                                                                   data_width=self.data_width,
                                                                                   logger_handle=logger_handle+'.{{get_inst_name(node)}}[{{node_instance_index}}]',
                                                                                   inst_name='{{get_inst_name(node)}}')
                                       {%- if not loop.last -%} ,  {%- endif -%}
                                       {% endfor %} )
        {%- else -%}
    self.__{{get_inst_name(node)}} = {{get_fully_qualified_type_name(node)}}_cls(read_callback=read_callback,
                                                                                 write_callback=write_callback,
                                                                                 base_address=base_address+{{node.address_offset}},
                                                                                 address_width=self.address_width,
                                                                                 data_width=self.data_width,
                                                                                 logger_handle=logger_handle+'.{{get_inst_name(node)}}',
                                                                                 inst_name='{{get_inst_name(node)}}')
        {%- endif %}
    {%- endif %}
{%- endmacro %}

{%- macro regfile_class(node) %}
class {{get_fully_qualified_type_name(node)}}_cls(RegFile):
    """
    Class to represent a register file in the register model

    {{get_table_block(node) | indent}}
    """

    __slots__ = [{%- for child_node in node.children(unroll=False) -%}'__{{get_inst_name(child_node)}}'{% if not loop.last %}, {% endif %}{%- endfor %}]

    def __init__(self,
                 read_callback: read_callback_type,
                 write_callback: write_callback_type,
                 logger_handle:str,
                 base_address:int,
                 address_width,
                 data_width,
                 inst_name):

        super().__init__(base_address=base_address,
                         address_width=address_width,
                         data_width=data_width,
                         logger_handle=logger_handle,
                         inst_name=inst_name)

        # instance of objects within the class
        {%- for child_node in node.children(unroll=False) -%}
            {{ regfile_or_addr_instance(child_node) | indent }}
        {%- endfor %}

    # properties for Register and RegisterFiles
    {%- for child_node in node.children(unroll=False) %}
        {%- if isinstance(child_node, systemrdlRegNode) or isinstance(child_node, systemrdlRegfileNode) %}
    @property
    def {{get_inst_name(child_node)}}(self) -> {%- if child_node.is_array -%}Tuple[{%- endif -%}{{get_fully_qualified_type_name(child_node)}}_cls{%- if child_node.is_array -%}, ...]{%- endif -%}:
        return self.__{{get_inst_name(child_node)}}
        {%- endif %}
    {% endfor %}

{%- endmacro %}

{%- macro addrmap_class(node) %}
class {{get_fully_qualified_type_name(node)}}_cls(AddressMap):
    """
    Class to represent a address map in the register model

    {{get_table_block(node) | indent}}
    """

    __slots__ = [{%- for child_node in node.children(unroll=False) -%}{%- if isinstance(child_node, systemrdlRegNode) or isinstance(child_node, systemrdlRegfileNode) or isinstance(child_node, systemrdlAddrmapNode) -%}'__{{get_inst_name(child_node)}}'{% if not loop.last %}, {% endif %}{% endif %}{%- endfor %}]

    def __init__(self,
                 read_callback: read_callback_type,
                 write_callback: write_callback_type,
                 base_address:int {%- if node == top_node -%}={{top_node.absolute_address}}{%- endif -%},
                 logger_handle:str {%- if node == top_node -%}='reg_model.{{top_node.get_path()}}'{%- endif -%},
                 inst_name{%- if node == top_node -%}='{{get_inst_name(node)}}'{%- endif -%},
                 address_width=32,
                 data_width=32):

        super().__init__(base_address=base_address,
                         address_width=address_width,
                         data_width=data_width,
                         logger_handle=logger_handle,
                         inst_name=inst_name)

        {% for child_node in node.children(unroll=False) -%}
            {{ regfile_or_addr_instance(child_node) | indent }}
        {% endfor %}

        {%- for child_node in node.children(unroll=False) -%}
            {%- if isinstance(child_node, systemrdlRegNode) or isinstance(child_node, systemrdlRegfileNode) or isinstance(child_node, systemrdlAddrmapNode) %}
    @property
    def {{get_inst_name(child_node)}}(self) ->  {%- if child_node.is_array -%}Tuple[{%- endif -%}{{get_fully_qualified_type_name(child_node)}}_cls{%- if child_node.is_array -%},...]{%- endif -%}:
        return self.__{{get_inst_name(child_node)}}
            {%- endif %}
        {% endfor %}
{%- endmacro %}

{% if top_node.uses_enum %}
# root level enum definitions
{%- for enum_needed in get_dependent_enum(top_node.parent) %}
@unique
class {{get_fully_qualified_enum_type(enum_needed, top_node.parent)}}_enumcls(IntEnum):

    {% for value_of_enum_needed in enum_needed -%}
    {{ value_of_enum_needed.name }} = {{ value_of_enum_needed.value }}  {%- if value_of_enum_needed.rdl_desc is not none -%}# {{ value_of_enum_needed.rdl_desc }} {%- endif %}
    {% endfor %}
{% endfor -%}
{% endif %}


# regfile, register and field definitions
{%- for node in get_dependent_component(top_node.parent) -%}
    {% if isinstance(node, systemrdlRegNode) %}
        {{ register_class(node)  }}
    {% elif isinstance(node, systemrdlRegfileNode) %}
        {{ regfile_class(node) }}
    {% elif isinstance(node, systemrdlAddrmapNode) %}
        {{ addrmap_class(node) }}
    {% elif isinstance(node, systemrdlFieldNode) %}
        {{ field_class(node)  }}
    {% endif %}
{% endfor %}


if __name__ == '__main__':
    # dummy functions to demonstrate the class
    def read_addr_space(addr: int):
        assert isinstance(addr, int)
        return input('value to read from address:0x%X'%addr)

    def write_addr_space(addr: int, data: int):
        assert isinstance(addr, int)
        assert isinstance(data, int)
        print('write data:0x%X to address:0x%X'%(data, addr))

    # create an instance of the class
    {{get_inst_name(top_node)}} = {{get_fully_qualified_type_name(top_node)}}_cls(read_callback=read_addr_space, write_callback=write_addr_space)
